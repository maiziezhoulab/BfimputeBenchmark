#' The gene-gene interaction analysis using WGCNA and clusterProfile
#'
#' @param Bf.list.G The list of gene latent matrices generated by Bfimpute
#' @param ont One of "BP", "MF", and "CC" subontologies. (from \code{enrichGO})
#'
#' @return a list of WGCNA network results and enrichGO results.
#' @export
#' @import WGCNA cluster clusterProfiler org.Hs.eg.db
#'
#' @examples
#'
gg_analysis <- function(Bf.list.G, ont = "CC"){
  gene.ego.all = list()
  for(i in seq(Bf.list.G)){
    # for(i in 4:7){
    Bf.C.matrix.i = Bf.list.G[[i]]
    rownames(Bf.C.matrix.i) = paste0("Latent",seq(nrow(Bf.C.matrix.i)))
    ArrayName = rownames(Bf.C.matrix.i)
    GeneName = colnames(Bf.C.matrix.i)

    # genes.all.map = bitr(GeneName,
    #                      "SYMBOL",
    #                      "ENTREZID",
    #                      org.Hs.eg.db,
    #                      drop = T)
    # genes.all.entrezedID = genes.all.map[,2]

    # --------------------------------- One-Step --------------------------------- #
    powers = c(c(1:10), seq(from = 12, to=20, by=2))
    # Call the network topology analysis function
    sft = pickSoftThreshold(Bf.C.matrix.i, powerVector = powers, verbose = 5)
    # PlotSTF(stf, powers)
    if(is.na(sft$powerEstimate))
      sft$powerEstimate = 6
    net = blockwiseModules(
      Bf.C.matrix.i,
      power = sft$powerEstimate,
      # maxBlockSize = length(GeneName),
      maxBlockSize = 6000,
      TOMType = "unsigned", minModuleSize = 200,
      reassignThreshold = 0, mergeCutHeight = 0.25,
      numericLabels = TRUE, pamRespectsDendro = FALSE,
      saveTOMs = TRUE,
      saveTOMFileBase = paste0(mid_dir, "NetTOMFile_", i),
      verbose = 3
    )

    # Convert labels to colors for plotting
    moduleLabels = net$colors
    table(moduleLabels)

    mergedColors = labels2colors(moduleLabels)
    # table(mergedColors)

    # # Plot the dendrogram and the module colors underneath
    # plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
    #                     "Module colors",
    #                     dendroLabels = FALSE, hang = 0.03,
    #                     addGuide = TRUE, guideHang = 0.05)
    # ## assign all of the gene to their corresponding module
    # ## hclust for the genes.

    # module.selected = 3
    ego.list = list()
    for(ii in sort(unique(moduleLabels)+1)){
      module.selected = ii - 1

      genes.selected = GeneName[moduleLabels == module.selected]

      genes.selected.map = bitr(genes.selected,
                                "SYMBOL",
                                "ENTREZID",
                                org.Hs.eg.db,
                                drop = T)

      genes.selected.entrezedID = genes.selected.map[,2]

      # # CC: Cellular component
      # # BP: Biological process
      # # MF: Molecular function
      ego <- enrichGO(gene          = genes.selected.entrezedID,
                      OrgDb         = org.Hs.eg.db,
                      keyType       = "ENTREZID",
                      ont           = ont,      # CC, BP, MF
                      pAdjustMethod = "BH",
                      pvalueCutoff  = 0.1,
                      qvalueCutoff  = 0.1,
                      readable      = TRUE)
      ego.list[[ii]] = ego
    }
    gene.ego.all[[i]] = list(net = net, ego.list = ego.list)
  }
  return(gene.ego.all)
}


### ----------------- ###
PlotSTF <- function(stf, powers){
  # Plot the results:
  ##sizeGrWindow(9, 5)
  par(mfrow = c(1,2));
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.90,col="red")
  # Mean connectivity as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], sft$fitIndices[,5],
       xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
       main = paste("Mean connectivity"))
  text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
}

blockwiseModules <- function(...){
  cor <- WGCNA::cor
  net = WGCNA::blockwiseModules(...)
  rm(cor)
  return(net)
}

# # ego = ego.npc.list[[3]] # 1
# # ego = ego.hff.list[[1]] # 1
# # ego = ego.tb.list[[3]] # 3
# # ego = ego.ec.list[[1]] # 1
#
# p = barplot(ego, showCategory=26)
# # dotplot(ego)
# ego@result = ego@result[-c(3,5,17), ]
# q = cnetplot(ego, colorEdge = TRUE, showCategory = 10)

